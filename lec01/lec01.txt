anagram だけを全通り列挙するとO(n!) 辞書の二分探索でO(logN)
アナグラム文字列のソートO(logn)と辞書側のソートをする（元の単語もセットで保存しておく必要がある）ことで新しい辞書と比較することで二分探索すれば早くなる
辞書をソートするところが1番operationが多いO(nlogn)

辞書が10万語 9文字目までだったら前の方法が早い

ただ辞書のソートは一回だけで良い
辞書並び替えnlogn
単語を二分探索lognを単語数だけ

一つずつ前から探すのではなく二分探索->単語も辞書もアルファベット準備並び替えNlogN + QlogNs

##与えられた文字列のアナグラムを辞書ファイルから探して返すプログラムを作る 自分で何個かテストケースを作る
簡単なテストケースから、極端な例について(1番長い英単語をいれる、顔文字など、空文字、カナ文字を入力してみる、存在しない単語、アナグラムが複数ある場合、見つからなかった場合の場合わけ)

#全ての文字を使わなくて良い

アナグラムの文字数をカウントして、それ以下の文字数の辞書をそれぞれアルファベット順にソートする
それか一回先に辞書の文字数での分類をやってしまったら今後使える

木をつかってそれまでに見つかったらそこも含める

使う文字を選択する2^n->並び替えN!->log辞書の単語数
使う文字を選択2^N-> 文字をソートで辞書をソート->ソートされた辞書から二分探索

文字の入っている単語を作れることがわかればいい
a1c1r1d1とカウントしておき、辞書もカウントしておく 部分集合サブセットなので両方作れる 辞書の単語を順に比較
26文字しかないから小さな計算量になると思われる

##与えられたmオジ列のすべての文字を使わなくても良いように関数をアップグレードする
書く単語について最大のスコアを